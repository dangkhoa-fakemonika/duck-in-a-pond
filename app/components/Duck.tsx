/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import * as THREE from 'three'
import React, { useRef, useEffect } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame, useThree, ThreeEvent } from '@react-three/fiber'

type DuckProps = JSX.IntrinsicElements['group'] & {
  impulse?: { point: THREE.Vector3; id: number } | null
}
const WAVE_SPEED = 3.25;

export function Duck({ impulse, ...props }: DuckProps) {
  const { nodes, materials } = useGLTF('/duck.gltf') as any
  const groupRef = useRef<THREE.Group>(null)
  const { viewport } = useThree()
  const tiltRef = useRef({ x: 0, z: 0 })

  const FRICTION = 0.98
  const PUSH_STRENGTH = 0.1
  const ROTATION_SPEED = 0.08
  const DUCK_RADIUS = 1.5
  const MAX_INFLUENCE_DIST = 10
  const WATER_LEVEL = 0.5

  const TILT_SENSITIVITY = 0.02

  const velocity = useRef(new THREE.Vector3(0, 0, 0))

  useEffect(() => {
    const handleOrientation = (event: DeviceOrientationEvent) => {
      const { gamma, beta } = event

      if (gamma === null || beta === null) return
      const xForce = Math.min(Math.max(gamma, -45), 45) / 45
      const zForce = Math.min(Math.max(beta, -45), 45) / 45

      tiltRef.current = { x: xForce, z: zForce }
    }

    window.addEventListener('deviceorientation', handleOrientation)
    return () => window.removeEventListener('deviceorientation', handleOrientation)
  }, [])

  useEffect(() => {
    if (!impulse || !groupRef.current) return

    const duckPos = groupRef.current.position
    const clickPos = impulse.point

    const distance = duckPos.distanceTo(clickPos)
    const delayMs = (distance / WAVE_SPEED) * 1000 - 200

    const safeDelay = Math.max(0, delayMs)

    const timer = setTimeout(() => {
      if (!groupRef.current) return;
      const currentDuckPos = groupRef.current.position
      const direction = new THREE.Vector3()
        .subVectors(currentDuckPos, clickPos)
        .normalize()

      direction.y = 0

      const currentDist = currentDuckPos.distanceTo(clickPos)
      if (currentDist <= MAX_INFLUENCE_DIST) {
        const scaledForce = PUSH_STRENGTH * (1 - (currentDist / MAX_INFLUENCE_DIST))
        velocity.current.add(direction.multiplyScalar(scaledForce))
      }

      velocity.current.y += 0.05

    }, safeDelay)
    return () => clearTimeout(timer)

  }, [impulse])

  useEffect(() => {
    const preloadAudio = new Audio('/quack.mp3')
    preloadAudio.preload = 'auto'
    preloadAudio.load()
  }, [])

  const playQuack = (e: ThreeEvent<MouseEvent>) => {
    e.stopPropagation()
    const audio = new Audio('/quack.mp3')
    audio.volume = 0.5

    audio.playbackRate = 0.9 + Math.random() * 0.2;
    audio.play().catch(err => console.error("Audio failed:", err))
  }

  useFrame(() => {
    if (!groupRef.current) return
    const mesh = groupRef.current
    const vel = velocity.current

    vel.x += tiltRef.current.x * TILT_SENSITIVITY
    vel.z += tiltRef.current.z * TILT_SENSITIVITY

    mesh.position.x += vel.x
    mesh.position.z += vel.z

    mesh.position.y = WATER_LEVEL

    vel.multiplyScalar(FRICTION)

    const limitX = viewport.width / 2 - DUCK_RADIUS
    const limitZ = viewport.height / 2 - DUCK_RADIUS

    if (mesh.position.x > limitX) { mesh.position.x = limitX; vel.x *= -0.5 }
    if (mesh.position.x < -limitX) { mesh.position.x = -limitX; vel.x *= -0.5 }
    if (mesh.position.z > limitZ) { mesh.position.z = limitZ; vel.z *= -0.5 }
    if (mesh.position.z < -limitZ) { mesh.position.z = -limitZ; vel.z *= -0.5 }

    if (new THREE.Vector2(vel.x, vel.z).length() > 0.001) {
      const targetRotation = Math.atan2(vel.x, vel.z)
      const currentRotation = mesh.rotation.y

      let diff = targetRotation - currentRotation
      while (diff > Math.PI) diff -= Math.PI * 2
      while (diff < -Math.PI) diff += Math.PI * 2

      mesh.rotation.y += diff * ROTATION_SPEED
    }
  })

  const { scale, ...restProps } = props as any

  return (
    <group
      ref={groupRef}
      scale={[0.5, 0.5, 0.5]}
      {...restProps}
      dispose={null}
      onClick={playQuack}
      onPointerOver={() => document.body.style.cursor = 'pointer'}
      onPointerOut={() => document.body.style.cursor = 'auto'}
    >
      <group rotation={[Math.PI / 2, 0, 0]}>
        <mesh geometry={nodes.Object_4.geometry} material={materials.Yellow} />
        <mesh geometry={nodes.Object_5.geometry} material={materials.beak} />
        <mesh geometry={nodes.Object_6.geometry} material={materials['Material.001']} />
        <mesh geometry={nodes.Object_7.geometry} material={materials.glare} />
      </group>
    </group>
  )
}

useGLTF.preload('/duck.gltf')